name: Build and Deploy

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - '.cursorrules'
      - 'LICENSE'

env:
  INSTANCE_DIR: /var/lib/virga-plateform/instances
  BACKUP_DIR: /var/lib/virga-plateform/backups
  DOCKER_REGISTRY: rehanalimahomed/virga-plateform
  COMPANY_DOMAIN: amadiy.com
  PROXY_USER: amadiyadm
  PROXY_HOST: ${{ secrets.PROXY_HOST }}
  PROXY_MANAGER_DIR: /home/amadiyadm/proxy-settings
  APP_SERVER_IP: ${{ secrets.DOCKERS_HOST }}

jobs:
  initialize:
    name: ðŸ”§ Initialize and List Instances
    runs-on: self-hosted
    outputs:
      version: ${{ steps.version.outputs.version }}
      display_version: ${{ steps.version.outputs.display_version }}
      active_instances: ${{ steps.list-instances.outputs.instances }}
    
    steps:
    - name: Check Environment
      run: |
        echo "ðŸ” Checking environment configuration..."
        echo "Instance Directory: $INSTANCE_DIR"
        echo "Backup Directory: $BACKUP_DIR"
        echo "Current User: $(whoami)"
        echo "Docker Status: $(docker info | grep 'Server Version')"
        
        # Verify directories exist
        for dir in "$INSTANCE_DIR" "$BACKUP_DIR"; do
          if [ ! -d "$dir" ]; then
            echo "Creating directory: $dir"
            sudo mkdir -p "$dir"
            sudo chown $CURRENT_USER:$CURRENT_USER "$dir"
          fi
        done
        
        # Validate required environment variables
        required_vars=("PROXY_HOST" "APP_SERVER_IP" "PROXY_MANAGER_DIR" "PROXY_USER")
        for var in "${required_vars[@]}"; do
          if [ -z "${!var}" ]; then
            echo "::error::Required environment variable $var is not set"
            exit 1
          fi
        done
        
        # Check Docker login status
        if ! docker info | grep -q "Username"; then
          echo "::warning::Docker Hub login not found. Will need to login during workflow."
          echo "NEED_DOCKER_LOGIN=true" >> $GITHUB_ENV
        else
          echo "âœ… Docker Hub already logged in"
          echo "NEED_DOCKER_LOGIN=false" >> $GITHUB_ENV
        fi

    - name: Checkout code
      uses: actions/checkout@v3
      with:
        clean: true
        fetch-depth: 0
        
    - name: Generate Version
      id: version
      run: |
        # Get base version from file
        BASE_VERSION=$(cat VERSION)
        BUILD_DATE=$(date +'%Y.%m.%d')
        GIT_SHORT_SHA=$(git rev-parse --short HEAD)
        BUILD_NUMBER=$(git rev-list --count HEAD)
        
        # Generate versions
        TECHNICAL_VERSION="${BASE_VERSION}-${BUILD_NUMBER}-${GIT_SHORT_SHA}"
        DISPLAY_VERSION="${BASE_VERSION} (${BUILD_DATE} build ${BUILD_NUMBER})"
        
        # Export versions
        echo "version=${TECHNICAL_VERSION}" >> $GITHUB_OUTPUT
        echo "display_version=${DISPLAY_VERSION}" >> $GITHUB_OUTPUT
        
        # Save to .env
        cat > .env << EOL
        VERSION=${TECHNICAL_VERSION}
        DISPLAY_VERSION=${DISPLAY_VERSION}
        BUILD_DATE=${BUILD_DATE}
        GIT_SHA=${GIT_SHORT_SHA}
        BUILD_NUMBER=${BUILD_NUMBER}
        EOL

    - name: List Active Instances
      id: list-instances
      run: |
        # Create temporary file for instances
        instance_file="${RUNNER_TEMP}/active_instances.txt"
        > "$instance_file"
        
        # Find and store active instances
        while IFS= read -r dir; do
          instance_id=$(basename "$dir")
          
          # Skip test and preprod instances
          if [[ "$instance_id" != test-* ]] && [[ "$instance_id" != preprod-* ]]; then
            if [ -f "$dir/secrets.env" ]; then
              container_name="${instance_id}-plateform"
              
              # Check if instance is running
              if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
                # Read domain from secrets.env safely
                domain=$(grep "^DOMAIN=" "$dir/secrets.env" | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr -d ' ')
                if [ -n "$domain" ]; then
                  printf "%s|%s|%s\n" "$instance_id" "$domain" "$dir" >> "$instance_file"
                fi
              fi
            fi
          fi
        done < <(find ${INSTANCE_DIR} -name "docker-compose.yml" -exec dirname {} \;)
        
        # Validate we found instances
        if [ ! -s "$instance_file" ]; then
          echo "::warning::No active instances found"
          echo "instances=" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Convert instances to a single line with proper escaping
        instances=$(cat "$instance_file" | tr '\n' ',' | sed 's/,$//')
        echo "instances=${instances}" >> $GITHUB_OUTPUT
        echo "Found active instances:"
        cat "$instance_file"

  backup:
    name: ðŸ“¦ Backup Production Databases
    needs: initialize
    runs-on: self-hosted
    
    steps:
    - name: Backup Production Databases
      run: |
        timestamp=$(date +%Y%m%d_%H%M%S)
        IFS=',' read -ra instance_array <<< "${{ needs.initialize.outputs.active_instances }}"
        
        echo "ðŸ”„ Processing instance backups..."
        
        # Exit if no instances
        [ -z "${{ needs.initialize.outputs.active_instances }}" ] && echo "No instances to backup" && exit 0
        
        # Process each instance
        for instance in "${instance_array[@]}"; do
          IFS='|' read -r id domain dir <<< "$instance"
          [ -z "$id" ] && continue
          
          echo "ðŸ“¦ Backing up instance: $id ($domain)"
          
          # Create backup directory
          backup_dir="${BACKUP_DIR}/${id}/backup_${timestamp}"
          mkdir -p "$backup_dir" || { echo "Failed to create backup dir for $id"; continue; }
          
          # Backup main database using VACUUM
          if [ -f "${dir}/db/database.sqlite" ]; then
            if ! echo ".backup '${backup_dir}/database.sqlite'" | sqlite3 "${dir}/db/database.sqlite"; then
              echo "Failed to backup database for $id"
              continue
            fi
            echo "âœ“ Database backed up to: ${backup_dir}/database.sqlite"
          fi
          
          # Copy database for preprod
          preprod_dir="${INSTANCE_DIR}/preprod-${id}"
          mkdir -p "${preprod_dir}/db" || { echo "Failed to create preprod dir for $id"; continue; }
          
          if [ -f "${dir}/db/database.sqlite" ]; then
            if ! echo ".backup '${preprod_dir}/db/database.sqlite'" | sqlite3 "${dir}/db/database.sqlite"; then
              echo "Failed to copy database to preprod for $id"
              continue
            fi
            echo "âœ“ Database copied to preprod: ${preprod_dir}/db/database.sqlite"
          fi
        done

  build:
    name: ðŸ—ï¸ Build and Test Code
    needs: [initialize, backup]
    runs-on: self-hosted
    
    steps:
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
      
    - name: Run linting
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Build Docker image
      run: |
        docker build -t ${DOCKER_REGISTRY}:${{ needs.initialize.outputs.version }} .
        docker tag ${DOCKER_REGISTRY}:${{ needs.initialize.outputs.version }} ${DOCKER_REGISTRY}:latest
      
    - name: Login to Docker Hub
      if: env.NEED_DOCKER_LOGIN == 'true'
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Push Docker image
      run: |
        if ! docker push ${DOCKER_REGISTRY}:${{ needs.initialize.outputs.version }}; then
          if [ "${{ env.NEED_DOCKER_LOGIN }}" = "false" ]; then
            echo "::warning::Push failed, trying to login to Docker Hub..."
            echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
            docker push ${DOCKER_REGISTRY}:${{ needs.initialize.outputs.version }}
          else
            echo "::error::Failed to push Docker image"
            exit 1
          fi
        fi
        docker push ${DOCKER_REGISTRY}:latest

  test-deploy:
    name: ðŸ§ª Deploy & Verify Test Instance
    needs: [initialize, build]
    runs-on: self-hosted
    
    steps:
    - name: Deploy Test Instance
      id: deploy
      run: |
        export APP_VERSION=${{ needs.initialize.outputs.version }}
        export APP_DISPLAY_VERSION="${{ needs.initialize.outputs.display_version }}"
        
        # Set up test instance variables
        COMPANY_DIR="virga-plateform"
        TEST_DOMAIN="test-${COMPANY_DIR}.${COMPANY_DOMAIN}"
        TEST_INSTANCE_DIR="${INSTANCE_DIR}/test-${COMPANY_DIR}"

        # Check if deploy-instance.sh is executable
        if [ ! -x "./deploy-instance.sh" ]; then
          echo "Making deploy-instance.sh executable..."
          chmod +x ./deploy-instance.sh || sudo -n chmod +x ./deploy-instance.sh || {
            echo "::error::Failed to make deploy-instance.sh executable"
            exit 1
          }
        fi
        
        echo "ðŸš€ Deploying test instance to ${TEST_DOMAIN}..."
        
        ./deploy-instance.sh \
          --company-name="Test ${COMPANY_DIR}" \
          --company-address="Test Address" \
          --company-phone="0123456789" \
          --company-email="test@${COMPANY_DOMAIN}" \
          --domain="${TEST_DOMAIN}" \
          --admin-password="${{ secrets.TEST_ADMIN_PASSWORD }}" \
          --force
          
    - name: Verify Test Instance
      run: |
        COMPANY_DIR="virga-plateform"
        TEST_DOMAIN="test-${COMPANY_DIR}.${COMPANY_DOMAIN}"
        echo "ðŸ” Verifying test instance at ${TEST_DOMAIN}..."
        
        # Wait for instance to be ready
        for i in {1..10}; do
          if curl -sf "https://${TEST_DOMAIN}/health" > /dev/null; then
            echo "âœ… Test instance health check passed"
            exit 0
          fi
          echo "Waiting for instance to be ready... (attempt $i/10)"
          sleep 30
        done
        
        echo "âŒ Test instance health check failed after 10 attempts"
        exit 1

  deploy-preprod:
    name: ðŸš€ Deploy PreProduction Instances
    needs: [initialize, backup, test-deploy]
    runs-on: self-hosted
    environment: preprod
    
    steps:
    - name: Deploy PreProd Instances
      run: |
        export APP_VERSION=${{ needs.initialize.outputs.version }}
        instances='${{ needs.initialize.outputs.active_instances }}'
        
        # Exit if no instances
        [ -z "$instances" ] && echo "No instances to deploy" && exit 0
        
        # Create deployment report
        report_file="${RUNNER_TEMP}/preprod_deployment.txt"
        echo "PreProduction Deployment Report - $(date)" > "$report_file"
        
        # Process each instance
        echo "$instances" | while IFS='|' read -r id domain dir; do
          [ -z "$id" ] && continue
          
          echo "ðŸ”„ Deploying preprod for: $id"
          echo "Instance: $id ($domain)" >> "$report_file"
          
          preprod_domain="preprod-${domain}"
          
          if ./deploy-instance.sh \
            --company-name="PreProd ${id}" \
            --domain="${preprod_domain}" \
            --force \
            --update-only; then
            echo "âœ“ Deployed: ${preprod_domain}" >> "$report_file"
            
            # Verify deployment with retries
            for i in {1..5}; do
              if curl -sf "https://${preprod_domain}/health" > /dev/null; then
                echo "âœ“ Health check passed" >> "$report_file"
                break
              fi
              if [ $i -eq 5 ]; then
                echo "âœ— Health check failed after 5 attempts" >> "$report_file"
              else
                echo "Retrying health check... (attempt $i/5)"
                sleep 30
              fi
            done
          else
            echo "âœ— Deployment failed" >> "$report_file"
          fi
          
          echo "---" >> "$report_file"
        done
        
        # Save report
        mkdir -p "${GITHUB_WORKSPACE}/reports"
        cp "$report_file" "${GITHUB_WORKSPACE}/reports/preprod_$(date +%Y%m%d_%H%M%S).txt"
        
    - name: Upload PreProd Report
      uses: actions/upload-artifact@v3
      with:
        name: preprod-deployment-report
        path: reports/
        retention-days: 30

  approve-production:
    name: âœ‹ Approve Production Deployment
    needs: [initialize, deploy-preprod]
    runs-on: self-hosted
    environment:
      name: production
      url: ${{ steps.deployment-urls.outputs.urls }}
    
    steps:
    - name: List Deployment URLs
      id: deployment-urls
      run: |
        instances='${{ needs.initialize.outputs.active_instances }}'
        
        # Exit if no instances
        [ -z "$instances" ] && echo "urls=" >> $GITHUB_OUTPUT && exit 0
        
        urls=""
        while IFS='|' read -r id domain dir; do
          [ -z "$id" ] && continue
          urls="${urls}https://preprod-${domain}\n"
        done <<< "$instances"
        
        echo "urls=${urls}" >> $GITHUB_OUTPUT

  deploy-production:
    name: ðŸš€ Deploy Production Instances
    needs: [initialize, approve-production]
    runs-on: self-hosted
    
    steps:
    - name: Deploy to Production
      run: |
        export APP_VERSION=${{ needs.initialize.outputs.version }}
        instances='${{ needs.initialize.outputs.active_instances }}'
        
        # Exit if no instances
        [ -z "$instances" ] && echo "No instances to deploy" && exit 0
        
        # Create deployment report
        report_file="${RUNNER_TEMP}/production_deployment.txt"
        echo "Production Deployment Report - $(date)" > "$report_file"
        
        # Process each instance
        while IFS='|' read -r id domain dir; do
          [ -z "$id" ] && continue
          
          echo "ðŸ”„ Updating: $id ($domain)"
          echo "Instance: $id ($domain)" >> "$report_file"
          
          if ./deploy-instance.sh \
            --company-name="${id}" \
            --domain="${domain}" \
            --force \
            --update-only; then
            echo "âœ“ Deployed successfully" >> "$report_file"
            
            # Verify deployment with retries
            for i in {1..5}; do
              if curl -sf "https://${domain}/health" > /dev/null; then
                echo "âœ“ Health check passed" >> "$report_file"
                break
              fi
              if [ $i -eq 5 ]; then
                echo "âœ— Health check failed after 5 attempts" >> "$report_file"
              else
                echo "Retrying health check... (attempt $i/5)"
                sleep 30
              fi
            done
          else
            echo "âœ— Deployment failed" >> "$report_file"
          fi
          
          echo "---" >> "$report_file"
        done <<< "$instances"
        
        # Save report
        mkdir -p "${GITHUB_WORKSPACE}/reports"
        cp "$report_file" "${GITHUB_WORKSPACE}/reports/production_$(date +%Y%m%d_%H%M%S).txt"
        
    - name: Upload Production Report
      uses: actions/upload-artifact@v3
      with:
        name: production-deployment-report
        path: reports/
        retention-days: 30

  cleanup:
    name: ðŸ§¹ Cleanup and Report
    needs: [initialize, deploy-production]
    if: always()
    runs-on: self-hosted
    
    steps:
    - name: Cleanup Old Backups
      run: |
        # Keep only last 5 backups for each instance
        find ${BACKUP_DIR} -mindepth 1 -maxdepth 1 -type d | while read instance_dir; do
          cd "$instance_dir"
          ls -t | tail -n +6 | xargs -r rm -rf
        done
        echo "ðŸ§¹ Cleaned up old backups"
        
    - name: Generate Final Report
      run: |
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "âœ… Deployment Pipeline Complete"
          echo "Version: ${{ needs.initialize.outputs.display_version }}"
          echo "Technical version: ${{ needs.initialize.outputs.version }}"
          echo "Check deployment reports for details"
        else
          echo "âŒ Deployment Pipeline Failed"
          echo "Version: ${{ needs.initialize.outputs.display_version }}"
          echo "Check deployment reports for error details"
        fi